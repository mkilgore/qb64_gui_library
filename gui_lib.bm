'FTP Client
'Copyright Matt Kilgore -- 2011/2013

'This program is free software, without any warranty of any kind.
'You are free to edit, copy, modify, and redistribute it under the terms
'of the Do What You Want Public License, Version 1, as published by Matt Kilgore
'See file COPYING that should have been included with this source.
FUNCTION GUI_move_to_next_gui (movement$, current_selected, gui() AS gui_type, gui_num)
'function moves to next gui based on
selected_row = gui(current_selected).row1
selected_col = gui(current_selected).col1
new_col = -1 'distance from selected object
new_row = -1
new_gui = -1
'DIM choices(UBOUND(gui)) AS INTEGER
'things are judged by distance
'in event that there are more then one selected item, which normally happens, we select the closer object

SELECT CASE movement$
  CASE CHR$(0) + CHR$(72) 'up
    FOR x = 1 TO gui_num
      IF gui(x).row1 < selected_row AND gui(x).row1 >= new_row THEN
        IF gui(x).col1 = new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_col = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).col1 < new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
  CASE CHR$(0) + CHR$(80) 'down
    FOR x = 1 TO gui_num
      IF gui(x).row1 > selected_row AND (gui(x).row1 <= new_row OR new_row = -1) THEN
        IF gui(x).col1 = new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_col = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).col1 < new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
  CASE CHR$(0) + CHR$(75) 'left
    FOR x = 1 TO gui_num
      IF gui(x).col1 < selected_col AND (gui(x).col1 >= new_col) THEN
        IF gui(x).row1 = new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_row = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).row1 > new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
  CASE CHR$(0) + CHR$(77) 'right
    FOR x = 1 TO gui_num
      IF gui(x).col1 > selected_col AND (gui(x).col1 <= new_col OR new_col = -1) THEN
        IF gui(x).row1 = new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_row = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).row1 < new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
END SELECT
move_to_next_gui = new_gui
END FUNCTION

FUNCTION GUI_inkey$ (gui() AS gui_type, sel AS INTEGER)
ch$ = INKEY$
IF gui(sel).text_box THEN
  SELECT CASE ch$
    CASE " " TO "~"
      add_character gui(sel), ch$
      update_input_boxes = -1
    CASE CHR$(8)
      del_character gui(sel)
      update_input_boxes = -1
    CASE CHR$(0) + CHR$(75)
      IF gui(sel).text_position > 0 THEN
        gui(sel).text_position = gui(sel).text_position - 1
        IF gui(sel).text_position < gui(sel).text_offset THEN
          gui(sel).text_offset = gui(sel).text_offset - 1
        END IF
        update_input_boxes = -1
      END IF
    CASE CHR$(0) + CHR$(77)
      IF gui(sel).text_position < gui(sel).text.length THEN
        gui(sel).text_position = gui(sel).text_position + 1
        IF gui(sel).text_position > gui(sel).text_offset + (gui(sel).col2 - gui(sel).col1 - 1) THEN
          gui(sel).text_offset = gui(sel).text_offset + 1
        END IF
        update_input_boxes = -1
      END IF
  END SELECT
END IF
GUI_inkey$ = ch$
END FUNCTION

SUB GUI_draw_box (b as gui_type)
IF b.shadow THEN
  FOR x = b.row1 + 1 TO b.row2 + 1
    FOR y = b.col1 + 2 TO b.col2 + 2
      chr = SCREEN(x, y)
      colo = SCREEN(x, y, 1)
      LOCATE x, y
      COLOR colo MOD 8, 0
      PRINT CHR$(chr);
    NEXT y
  NEXT x
END IF
IF b.scroll THEN b.scroll_loc = INT((b.scroll_offset) / (b.length - (b.row2 - b.row1 - 1)) * (b.row2 - b.row1 - 4) + b.row1 + 2)
n$ = get_str$(b.nam)
COLOR b.c1, b.c2
LOCATE b.row1, b.col1
PRINT CHR$(218); CHR$(196); n$; STRING$(b.col2 - b.col1 - 2 - LEN(n$), 196); CHR$(191);
FOR x = b.row1 + 1 TO b.row2 - 1
  LOCATE x, b.col1
  COLOR b.c1, b.c2
  PRINT CHR$(179); SPACE$(b.col2 - b.col1 - 1);
  IF b.scroll = 0 THEN
    PRINT CHR$(179);
  END IF
  IF b.scroll AND 1 THEN
    COLOR 7
    SELECT CASE x
      CASE b.row1 + 1
        COLOR 0, 7
        PRINT CHR$(24);
      CASE b.row2 - 1
        COLOR 0, 7
        PRINT CHR$(25);
      CASE ELSE
        COLOR 0, 7
        IF b.scroll_loc = x THEN
          PRINT CHR$(219);
        ELSE
          PRINT CHR$(176);
        END IF
    END SELECT
  END IF
NEXT x
COLOR b.c1 MOD 8, b.c2
LOCATE b.row2, b.col1
PRINT CHR$(192); STRING$(b.col2 - b.col1 - 1, 196); CHR$(217);
END SUB

'sel indiciates whether that box is a selected GUI element
'also -- as can be seen this is really just a wrapper around the real drawing SUB's
'SUB's are split up to simplify the process
SUB GUI_draw_element (b AS gui_type, sel) 'Draws box b -- this sub draws all the GUI parts
'Draws a box
IF b.element_type = 1 THEN 'Plain box
  GUI_draw_box b, sel
  
ELSEIF b.element_type = 2 THEN 'Input box
  GUI_draw_input_box b, sel
  
ELSEIF b.element_type = 3 THEN 'Multi-Line input box
  GUI_draw_multi_line_input_box b, sel
  
ELSEIF b.element_type = 4 THEN 'list box
  GUI_draw_list_box b, sel
  
ELSEIF b.element_type = 5 THEN 'Dropdown -- NOT DONE
  GUI_draw_dropdown b, sel
  
ELSEIF b.element_type = 6 THEN 'Checkbox
  GUI_draw_checkbox b, sel
  
ELSEIF b.element_type = 7 THEN
  GUI_draw_menu b, sel
  
ELSEIF b.element_type = 8 THEN 'Button
  GUI_draw_button b, sel

END IF
END SUB

SUB GUI_draw_checkbox (b as gui_type, sel)
LOCATE b.row1, b.col1
IF sel THEN COLOR b.sc1, b.sc2 ELSE COLOR b.c1 MOD 8, b.c2
PRINT "[";
IF b.checked THEN PRINT "X"; ELSE PRINT " ";
PRINT "]";
COLOR b.c1 MOD 8, b.c2
PRINT get_str$(b.nam);
END SUB

SUB GUI_draw_button (b as gui_type, sel)
LOCATE b.row1, b.col1
IF sel THEN COLOR b.sc1, b.sc2 ELSE COLOR b.c1 MOD 8, b.c2
PRINT "<";
'IF sel THEN COLOR b.selcol, b.c2 ELSE COLOR b.c1 MOD 8, b.c2
'COLOR b.c1 MOD 8, b.c2
PRINT get_str$(b.nam);
IF sel THEN COLOR b.sc1, b.sc2 ELSE COLOR b.c1 MOD 8, b.c2
PRINT ">";
END SUB

SUB GUI_draw_input_box (b as gui_type, sel)
GUI_draw_Box b
LOCATE b.row1 + 1, b.col1 + 1
s$ = MID$(get_str$(b.text), b.text_offset + 1, b.col2 - b.col1 - 1)
IF NOT b.hide THEN PRINT s$; ELSE PRINT STRING$(LEN(s$), "*");
END SUB

SUB GUI_draw_dropdown (b as gui_type, sel)
_CONTROLCHR OFF
LOCATE b.row1, b.col1
COLOR b.c1, b.c2
IF b.d_flag THEN PRINT CHR$(218); ELSE PRINT "[";
IF sel THEN COLOR b.sc1, b.sc2
PRINT LEFT$(get_str$(b.nam) + SPACE$(b.col2 - b.col1), b.col2 - b.col1 - 2); CHR$(31);
COLOR b.c1, b.c2
IF b.d_flag THEN PRINT CHR$(191); ELSE PRINT "]";
_CONTROLCHR ON
END SUB

SUB GUI_draw_menu (b as gui_type, sel)

END SUB

SUB GUI_draw_list_box (b as gui_type, sel)
GUI_draw_box b
for x = 1 to b.row2 - b.row1 - 1
  locate x + b.row1, b.col1 + 1
  if (b.selected - b.offset) = (x) then
    color b.sc1, b.sc2
  else
    color b.c1, b.c2
  end if
  print mid$(get_str_array$(b.multi_line, x + b.offset - 1), 1, b.col2 - b.col1 -1);
next x
END SUB

SUB GUI_draw_multi_line_input_box (b as gui_type, sel)

END SUB

FUNCTION mouse_range (b() AS gui_type, boxnum) 'Checks if mouse is in one of the boxes in b()
'Returns the array number if it is in one of them
mscroll = 0
DO WHILE _MOUSEINPUT
  mscroll = mscroll + _MOUSEWHEEL
  mx = _MOUSEX
  my = _MOUSEY
  but = _MOUSEBUTTON(1)
LOOP
IF but = -1 AND butflag = -1 THEN
  but = 0
  EXIT FUNCTION
ELSE
  butflag = 0
END IF
IF but = 0 THEN EXIT FUNCTION
butflag = -1
FOR x = 1 TO boxnum
  IF b(x).text_box THEN
    IF my <= b(x).row2 AND my >= b(x).row1 THEN
      IF mx >= b(x).col1 AND mx <= b(x).col2 THEN
        mouse_range = x
        IF my = b(x).row1 + 1 THEN
          IF mx > b(x).col1 + 1 AND mx < b(x).col2 - 1 THEN
            b(x).text_position = b(x).text_offset + mx - b(x).col1 - 1
            IF b(x).text_position > b(x).text.length THEN
              b(x).text_position = b(x).text.length
            END IF
            b(x).updated = -1
          END IF
        END IF
        EXIT FUNCTION
      END IF
    END IF
  ELSEIF b(x).menu then
    if my = b(x).row1 then
      b(x).updated = -1
      mouse_range = x
    end if
  ELSEIF b(x).multi_text_Box then
    IF my <= b(x).row2 AND my >= b(x).row1 THEN
      IF mx >= b(x).col1 AND mx <= b(x).col2 THEN
        mouse_range = x
        IF my = b(x).row1 + 1 THEN
          IF mx > b(x).col1 + 1 AND mx < b(x).col2 - 1 THEN
            b(x).text_position = b(x).text_offset + mx - b(x).col1 - 1
            IF b(x).text_position > b(x).text.length THEN
              b(x).text_position = b(x).text.length
            END IF
            b(x).updated = -1
          END IF
        END IF
        EXIT FUNCTION
      END IF
    END IF
  ELSEIF b(x).button THEN
    IF my = b(x).row1 AND mx >= b(x).col1 AND mx <= b(x).col1 + LEN(get_str$(b(x).nam)) + 1 THEN
      mouse_range = x
      EXIT FUNCTION
    END IF
  ELSEIF b(x).checkbox THEN
    IF my = b(x).row1 AND mx >= b(x).col1 AND mx <= b(x).col1 + 2 + LEN(get_str$(b(x).nam)) THEN
      mouse_range = x
      EXIT FUNCTION
    END IF
  ELSEIF b(x).drop_down THEN
    IF my = b(x).row1 AND mx >= b(x).col1 AND mx <= b(x).col2 THEN
      mouse_range = x
      EXIT FUNCTION
    END IF
  END IF
NEXT x
END FUNCTION

SUB print_menu_no_hilight (a$) 'Prints a$ without the '#' and no hilighting
PRINT MID$(a$, 1, INSTR(a$, "#") - 1);
PRINT MID$(a$, INSTR(a$, "#") + 1);
END SUB

SUB print_menu (a$, s) 'Prints a$ with the character after '#' hilighted in bright white
PRINT MID$(a$, 1, INSTR(a$, "#") - 1);
COLOR menu_char_c
PRINT MID$(a$, INSTR(a$, "#") + 1, 1);
COLOR s
PRINT MID$(a$, INSTR(a$, "#") + 2);
END SUB

FUNCTION menu_len (a$) 'Length of menu item a$.
'Just takes one away from the length if the string has a '#'`
IF INSTR(a$, "#") THEN
  menu_len = LEN(a$) - 1
ELSE
  menu_len = LEN(a$)
END IF
END FUNCTION

FUNCTION menu_char$ (a$) 'Get's the hilighted character
menu_char$ = MID$(a$, INSTR(a$, "#") + 1, 1)
END FUNCTION
